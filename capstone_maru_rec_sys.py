# -*- coding: utf-8 -*-
"""capstone-maru-rec-sys

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1C_53Ptx7nURS9aa0v8mL_YEc5OsVgpHA
"""

import random
import numpy as np
import pandas as pd
from sklearn.metrics.pairwise import cosine_similarity

genders = ['남성', '여성']
pets = ['강아지', '고양이', '없음']
smokes = [True, False]
personalities = ['외향적', '내향적', '낙관적', '비관적', '사교적', '내성적', '활동적', '수동적',
                '유머 감각 있음', '진지한', '지적', '감성적', '예술적', '실용적', '책임감 있음',
                '자유로운', '독립적', '의존적인']

def generate_person():
  return {
      '성별': random.choice(genders),
      '나이': random.randint(20, 60),
      '성격': sorted(random.sample(personalities, random.randint(1, len(personalities)))),
      '애완동물': random.choice(pets),
      '흡연여부': random.choice(smokes)
  }

def calculate_weighted_cosine_similarity(data1, data2, weights=[]):
  """
  각 벡터의 요소에 가중치를 계산한 후에, 코사인 유사도를 구한다.
  만약, 가중치 값이 주어지지 않는다면 모든 값을 1로 설정하고,
  길이가 다르다면 에러를 던진다.
  """

  if len(weights) == 0:
    weights = np.ones_like(data1)
  elif len(weights) != len(data1):
    raise Exception("가중치와 데이터의 크기가 일치하지 않습니다.")

  weighted_data1 = data1.multiply(weights, axis=1)
  weighted_data2 = data2.multiply(weights, axis=1)

  weighted_data1_magnitude1 = np.sqrt((weighted_data1 ** 2).sum(axis=1))
  weighted_data2_magnitude2 = np.sqrt((weighted_data2 ** 2).sum(axis=1))

  result = (weighted_data1.dot(weighted_data2.T) / (weighted_data1_magnitude1.values.reshape(-1, 1) * weighted_data2_magnitude2.values.reshape(1, -1)))
  return result.to_numpy()

user_data = [generate_person() for _ in range(30)]
user_post_data = [generate_person() for _ in range(30)]

columns = ['애완동물', '흡연여부', '성격']

user_data_df = pd.DataFrame(user_data, columns=columns)
user_post_data_df = pd.DataFrame(user_post_data, columns=columns)

for personality in personalities:
  mask = user_data_df['성격'].apply(lambda p: personality in p).astype(int)
  user_data_df[personality] = mask

  mask = user_post_data_df['성격'].apply(lambda p: personality in p).astype(int)
  user_post_data_df[personality] = mask

user_data_df.drop('성격', axis=1, inplace=True)
user_post_data_df.drop('성격', axis=1, inplace=True)

user_data_df['흡연여부'] = user_data_df['흡연여부'].astype(int)
user_post_data_df['흡연여부'] = user_post_data_df['흡연여부'].astype(int)

for pet in pets:
  mask = user_data_df['애완동물'].apply(lambda p: p == pet).astype(int)
  user_data_df[pet] = mask

  mask = user_post_data_df['애완동물'].apply(lambda p: p == pet).astype(int)
  user_post_data_df[pet] = mask

user_data_df.drop('애완동물', axis=1, inplace=True)
user_post_data_df.drop('애완동물', axis=1, inplace=True)

result = cosine_similarity(user_data_df, user_post_data_df)
result

def must_similar_age_range(data1, data2):
  return abs(data1['나이'] - data2['나이']) <= 10


def must_same_gender(data1, data2):
  return data1['성별'] == data2['성별']


def must_smoker(data1, data2):
  return data1['흡연여부'] == data2['흡연여부']


def must_same_pet(data1, data2):
  """애완 동물을 안키운다면, 안키우는 사람끼리, 키운다면 키우는 사람끼리"""
  if data1['애완동물'] == '없음' and data2['애완동물'] == '없음':
    return True
  if data1['애완동물'] != '없음' and data2['애완동물'] != '없음':
    return True
  return False


conditions = [
    must_same_gender,
    must_smoker,
    must_same_pet,
    must_similar_age_range
]


# 사용자 0번에게 추천되는 글 목록들
post_for_user0 = sorted(enumerate(result[0]), key=lambda x: x[1], reverse=True)

print('######### USER')
print(user_data[0])
for index, score in post_for_user0:
  for condition in conditions:
    if not condition(user_data[0], user_post_data[index]):
      break
  else:
    print(f'{score:.5f},', user_post_data[index])

# 글 0번에게 추천되는 사용자 목록들
user_for_post0 = sorted(enumerate(result[:, 0]), key=lambda x: x[1], reverse=True)

print()
print('######### POST')
print(user_post_data[0])
for index, score in user_for_post0:
  for condition in conditions:
    if not condition(user_post_data[0], user_data[index]):
      break
  else:
    print(f'{score:.5f},', user_data[index])

# 만약, 데이터베이스에서 없는 사람이 등장하면?

new_user = generate_person()
new_user_df = pd.DataFrame([new_user], columns=columns)

for personality in personalities:
  mask = new_user_df['성격'].apply(lambda p: personality in p).astype(int)
  new_user_df[personality] = mask

for pet in pets:
  mask = new_user_df['애완동물'].apply(lambda p: p == pet).astype(int)
  new_user_df[pet] = mask

new_user_df.drop('성격', axis=1, inplace=True)
new_user_df['흡연여부'] = new_user_df['흡연여부'].astype(int)

new_user_df.drop('애완동물', axis=1, inplace=True)

similar_users = cosine_similarity(new_user_df, user_pd_data)[0]
similar_users = sorted(enumerate(similar_users), key=lambda x: x[1], reverse=True)
similar_users = list(filter(lambda x: user_data[x[0]]['성별'] == new_user['성별'], similar_users))
similar_user = similar_users[0] if len(similar_users) else None

# 가장 비슷한 사람을 찾아주고 그 사람으로부터 추천 결과를 보여줌.
print(f'{new_user=}', f'{user_data[similar_user[0]]=}', sep='\n')
post_for_new_user = sorted(enumerate(result[similar_user[0]]), key=lambda x: x[1], reverse=True)
for index, score in post_for_new_user:
  for condition in conditions:
    if not condition(user_post_data[0], user_data[index]):
      break
  else:
    print(f'{score:.5f},', user_data[index])